b0 <- sort(runif(n.items, -b.lim, b.lim))
b1 <- apply_bias(b0, n.biased, bias, cancellation = F)
d0 <- b0*a0
d1 <- b1*a0
x0 <- rnorm(n.persons)
x1 <- impact[2]*rnorm(n.persons) + impact[1]
impact.hat <- (mean(x1) - mean(x0)) / sd(x0)
# Data gen
dat0 <- simdata(a0, d0, n.persons, '2PL', Theta = matrix(x0))
dat1 <- simdata(a0, d1, n.persons, '2PL', Theta = matrix(x1))
# Fit IRT models
fit0 <- mirt(dat0, 1, SE = T, SE.type = 'Oakes')
fit1 <- mirt(dat1, 1, SE = T, SE.type = 'Oakes')
# DIF Procedures
bsq.out <- irls(fit0, fit1, se = se_d)
bsq4.out <- irls(fit0, fit1, se = se_d4)
true.out <- true_weights(impact[1], fit0, fit1)
samp.out <- true_weights(impact.hat, fit0, fit1)
# m.test <- m_test(bsq2.out$optimize$minimum, fit0, fit1)
#lr.out <- lr(dat0, dat1)
#mh.out <- MH(dat0, dat1)
# Format output
dif <- data.frame(a0 = a0,
d0 = d0,
dgp = d1-d0 != 0,
bsq.true = true.out,
bsq.samp = samp.out,
bsq = bsq.out$weights,
bsq4 = bsq4.out$weights
#m.test = m.test,
#lr = lr.out$p,
#mh = mh.out$p
)
scale <- data.frame(bsq = bsq.out$optimize$minimum,
bsq4 = bsq4.out$optimize$minimum,
bsq.samp = impact.hat
#lr = lr.out$mu,
#mh = mh.out$mu,
#lasso = lasso.out$mu
)
list(dif = dif, scale = scale)
parallel::mclapply(1:n.reps, loop)
n500.6 <- n_sim(n.reps, n.persons = 500, n.items = 15, n.biased = 6, bias = .5, impact = c(.5, 1))
library(tidyverse)
### Data sim functions --------------------------------
n_sim <- function(n.reps = 100, n.persons = 500, n.items = 15, n.biased = 0, bias = .5, impact = c(0, 1)){
# Item hyper-parms
a.lower <- .9
a.upper <- 2.5
b.lim <- 1.5
# Sim loop for parallelization via mclapply
loop <- function(i){
# DGP
a0 <- runif(n.items, a.lower, a.upper)
b0 <- sort(runif(n.items, -b.lim, b.lim))
b1 <- apply_bias(b0, n.biased, bias, cancellation = F)
d0 <- b0*a0
d1 <- b1*a0
x0 <- rnorm(n.persons)
x1 <- impact[2]*rnorm(n.persons) + impact[1]
impact.hat <- (mean(x1) - mean(x0)) / sd(x0)
# Data gen
dat0 <- simdata(a0, d0, n.persons, '2PL', Theta = matrix(x0))
dat1 <- simdata(a0, d1, n.persons, '2PL', Theta = matrix(x1))
# Fit IRT models
fit0 <- mirt(dat0, 1, SE = T, SE.type = 'Oakes')
fit1 <- mirt(dat1, 1, SE = T, SE.type = 'Oakes')
# DIF Procedures
bsq.out <- irls(fit0, fit1, se = se_d)
bsq4.out <- irls(fit0, fit1, se = se_d4)
true.out <- true_weights(impact[1], fit0, fit1)
samp.out <- true_weights(impact.hat, fit0, fit1)
# m.test <- m_test(bsq2.out$optimize$minimum, fit0, fit1)
#lr.out <- lr(dat0, dat1)
#mh.out <- MH(dat0, dat1)
# Format output
dif <- data.frame(a0 = a0,
d0 = d0,
dgp = d1-d0 != 0,
bsq.true = true.out,
bsq.samp = samp.out,
bsq = bsq.out$weights,
bsq4 = bsq4.out$weights
#m.test = m.test,
#lr = lr.out$p,
#mh = mh.out$p
)
scale <- data.frame(bsq = bsq.out$optimize$minimum,
bsq4 = bsq4.out$optimize$minimum,
bsq.samp = impact.hat
#lr = lr.out$mu,
#mh = mh.out$mu,
#lasso = lasso.out$mu
)
list(dif = dif, scale = scale)
}
parallel::mclapply(1:n.reps, loop)
}
n500.6 <- n_sim(n.reps, n.persons = 500, n.items = 15, n.biased = 6, bias = .5, impact = c(.5, 1))
# DIF via scaling;
require(mirt)
require(GPCMlasso)
require(difR)
### IRLS functions ------------------------------
res_a <- function(log.sigma, fit0, fit1){
item_parms0 <- get_parms(fit0)
item_parms1 <- get_parms(fit1)
log(item_parms1$a) -  log(item_parms0$a)  - log.sigma
}
# SE(eij.a) (via delta method, need to double check)
se_a <- function(fit0, fit1){
a0 <- get_parms(fit0)$a
se_a0 <- get_se(fit0)$a
sqrt(2)/a0 * se_a0
}
res_d <- function(mu, fit0, fit1){
item_parms0 <- get_parms(fit0)
item_parms1 <- get_parms(fit1)
item_parms1$d/item_parms0$a - item_parms0$d/item_parms0$a - mu
}
se_d <- function(scale, fit0, fit1){
n.items <- length(fit0@Fit$h2)
item_parms0 <- get_parms(fit0)
a0 <- item_parms0$a
grad.ratio <- grad_ratio(scale, a0)
vcov0 <- vcov(fit0)
vcov1 <- vcov(fit1)
vcov.ratio <- vcov_ratio(vcov0, vcov1)
var.ratio <- var_ratio(grad.ratio, vcov.ratio)
sqrt(var.ratio)
}
se_d2 <- function(scale, fit0, fit1){
a0 <- get_parms(fit0)$a
se_d0 <- get_se(fit0)$d
se_d1 <- get_se(fit1)$d
sqrt(se_d0^2 + se_d1^2) / a0
}
grad_ratio <- function(scale, a0){
delta.a0 <- - scale / a0
delta.d0 <- - 1 / a0
delta.d1 <- 1 / a0
c(rbind(delta.a0, delta.d0, delta.d1))
}
vcov_ratio <- function(vcov0, vcov1){
m <- diag(1:n.items) %x% matrix(1, 2, 2)
v0 <- lapply(split(vcov0, m)[-1], matrix, 2)
v1 <- as.list(diag(vcov1)[(1:n.items) * 2])
vfull <- vector("list", n.items * 2)
vfull[1:(n.items) * 2 - 1] <- v0
vfull[1:(n.items) * 2 ] <- v1
Matrix::bdiag(vfull)
}
# sort out indices for 3 variables...
var_ratio <- function(grad.ratio, vcov.ratio){
out <- rep(0, n.items)
for(i in 1:n.items) {
j <- i*3-2
out[i] <- grad.ratio[j]^2 * vcov.ratio[j,j] +
2 * grad.ratio[j] * grad.ratio[(j+1)] * vcov.ratio[j,(j+1)] +
grad.ratio[(j+1)]^2 * vcov.ratio[(j+1),(j+1)] +
grad.ratio[(j+2)]^2 * vcov.ratio[(j+2), (j+2)]
}
out
}
# se_d3, Psi_prime, var-weights and var.tau, and m-test are for testing  e_i = Y_i - \hat theta = 0. Used
se_d3 <- function(scale, fit0, fit1){
n.items <- length(fit0@Fit$h2)
item_parms0 <- get_parms(fit0)
a0 <- item_parms0$a
grad.ratio <- grad_ratio(scale, a0)
vcov0 <- vcov(fit0)
vcov1 <- vcov(fit1)
vcov.ratio <- vcov_ratio(vcov0, vcov1)
var.ratio <- var_ratio(grad.ratio, vcov.ratio)
var.weights <- var_weights(scale, fit0, fit1)
var.tau <- var_tau(var.ratio, var.weights)
sqrt(var.tau)
}
psi_prime <- function(u, k){
w <- (u/k)^2
out <- 1 - 6*w + 5*w^2
out[abs(u) > k] <- 0
return(out)
}
var_weights <- function(scale, fit0, fit1) {
r <- res(scale, fit0, fit1)
se.r <- se_r(scale, fit0, fit1)
bsq.cuts <- bsq_cuts(se.r)
psi.prime <- psi_prime(r, bsq.cuts)
psi.prime / sum(psi.prime)
}
var_tau <- function(var.ratio, var.weights){
n <- length(var.weights)
W <- matrix(var.weights^2, nrow = n, ncol = n, byrow = T)
diag(W) <- 1 # This number s wrong? S/B 2?
c(W%*%as.matrix(var.ratio))
}
m_test <- function(scale, fit0, fit1) {
r <- res(scale, fit0, fit1)
se.r <- se_d3(scale, fit0, fit1)
(1 - pnorm(abs(r)/se.r, 0, 1)) * 2
}
# se_d4 and var.omega is for scaling e_i = Y_i - \hat \theta in bsq, assuming no item has DIF
se_d4 <- function(scale, fit0, fit1){
n.items <- length(fit0@Fit$h2)
item_parms0 <- get_parms(fit0)
a0 <- item_parms0$a
grad.ratio <- grad_ratio(scale, a0)
vcov0 <- vcov(fit0)
vcov1 <- vcov(fit1)
vcov.ratio <- vcov_ratio(vcov0, vcov1)
var.ratio <- var_ratio(grad.ratio, vcov.ratio)
var.omega <- var_omega(var.ratio)
sqrt(var.omega)
}
var_omega <- function(var.ratio){
n <- length(var.ratio)
var.bar <- median(var.ratio) # could choose something else..
(1 - 2/n) * var.ratio + (1/n) * var.bar
}
bsq_cuts <- function(se.r, alpha = .05){
se.r * qnorm(1 - alpha/2)
}
bsq_weight <- function(scale, fit0, fit1, se.r, alpha = .05){
# need to define res outside of this function
# Am I using the wrong weights? no, bsq.cuts is tau * cut
bsq.cuts <- se.r * qnorm(1 - alpha/2)
r <- res(scale, fit0, fit1)
w <- (1 - (r / bsq.cuts)^2)^2 * se.r
w[abs(r) > bsq.cuts] <- 0
w
}
wls <- function(scale, fit0, fit1, se.r, weights){
sum(weights * (res(scale, fit0, fit1) / se.r)^2)
}
irls <- function(fit0, fit1, parm = "d", se = se_d4, tol = 1e-3, maxit = 50){
nit <- 0
conv <- 1
previous <- 10000
res <- res_d
se_r <- se
#starts <- get_starts(fit0, fit1)
#scale <- starts[which.min(abs(starts))]
scale <- get_starts(fit0, fit1)
# Loop
while(nit < maxit & conv > 1e-3){
se.r <- se_r(scale, fit0, fit1)
#bsq.cuts <- bsq_cuts(se.r)
#weights <- bsq_weight(scale, fit0, fit1, bsq.cuts)
weights <- bsq_weight(scale, fit0, fit1, se.r)
wls.out <- optimize(f = wls,
interval = c(-10, 10),
fit0 = fit0,
fit1 = fit1,
se.r = se.r,
weights = weights)
# Update
scale <- wls.out$minimum
nit <- nit + 1
current <- wls.out$objective
conv <- abs(previous - current)
previous <- current
}
list(optimize = wls.out, n.iterations = nit, epsilon = conv, weights = weights)
}
### Helper functions -----------------------------
get_parms <- function(mirt_fit){
n.items <- length(mirt_fit@Fit$h2)
coef <- Reduce(rbind, coef(mirt_fit, printSE = T, IRTpars = F)[1:(n.items)])[, 1:2]
temp <- data.frame(coef[row.names(coef) == "par", ])
names(temp) <- c("a", "d")
temp
}
get_se <- function(mirt_fit){
n.items <- length(mirt_fit@Fit$h2)
coef <- Reduce(rbind, coef(mirt_fit, printSE = T, IRTpars = F)[1:(n.items)])[, 1:2]
temp <- data.frame(coef[row.names(coef) == "SE", ])
names(temp) <- c("a", "d")
temp
}
apply_bias <- function(b0, n.biased = 1, bias = .5, cancellation = F){
n.items <- length(b0)
biased.items <- sample(n.items, n.biased)
bias.vector <- 0*b0
bias.vector[biased.items] <- bias
if (cancellation == T) {
flip <- sample(c(-1, 1), n.biased)
bias.vector[biased.items] <- bias.vector[biased.items] * flip
}
b0 + bias.vector
}
true_weights <- function(mu, fit0, fit1){
se.r <- se_r(mu, fit0, fit1)
bsq.cuts  <- bsq_cuts(se.r)
bsq_weight(mu, fit0, fit1, bsq.cuts)
}
get_starts <- function(fit0, fit1){
r <- res(0, fit0, fit1)
n.items <- length(r)
# median residual
s1 <- median(r)
# # median std residual
# se.r <- se_r(s1, fit0, fit1)
# position <- order(r/se.r)
# p1 <- which(position == floor((n.items+1)/2))
# p2 <- which(position == ceiling((n.items+1)/2))
# s2 <- mean(c(r[p1], r[p2]))
#
# # median std residual, se winsorised at quartiles
# se.w <- winsorize(se.r)
# position <- order(r/se.w)
# p1 <- which(position == floor((n.items+1)/2))
# p2 <- which(position == ceiling((n.items+1)/2))
# s3 <- mean(c(r[p1], r[p2]))
#
# # median std residual, se trimmed at quartiles
# se.t <- trim(se.r)
# r.t <- trim(se.r, r)
# position <- order(r.t/se.t)
# n.items.t <- length(r.t)
# p1 <- which(position == floor((n.items.t+1)/2))
# p2 <- which(position == ceiling((n.items.t+1)/2))
# s4 <- mean(c(r[p1], r[p2]))
#c(s1, s2, s3, s4)
# median is def best
s1
}
winsorize <- function(x, lower.p = .25, upper.p = .25){
x.cut <- quantile(x, c(lower.p, 1- upper.p))
x[x < x.cut[1]] <- x.cut[1]
x[x > x.cut[2]] <- x.cut[2]
x
}
trim <- function(x, y = NULL, lower.p = .25, upper.p = .25){
x.cut <- quantile(x, c(lower.p, 1- upper.p))
if(is.null(y)) y <- x
y[x > x.cut[1] & x < x.cut[2]]
}
d_plot <- function(mu, muhat, fit0, fit1) {
item_parms0 <- get_parms(fit0)
item_parms1 <- get_parms(fit1)
a0 <- item_parms0$a
d0 <- item_parms0$d
d1 <- item_parms1$d
y <- d1/a0
x <- d0/a0
plot(x, y)
abline(mu, 1, col = 2)
abline(muhat, 1, col = 3)
}
### Data sim functions --------------------------------
data_simulation <- function(n.reps = 100, n.persons = 500, n.items = 15, n.biased = 0, bias = .5, impact = c(0, 1)){
# Item hyper-parms
a.lower <- .9
a.upper <- 2.5
b.lim <- 1.5
# Sim loop for parallelization via mclapply
loop <- function(i){
# DGP
a0 <- runif(n.items, a.lower, a.upper)
b0 <- sort(runif(n.items, -b.lim, b.lim))
b1 <- apply_bias(b0, n.biased, bias, cancellation = F)
d0 <- b0*a0
d1 <- b1*a0
x0 <- rnorm(n.persons)
x1 <- impact[2]*rnorm(n.persons) + impact[1]
# Data gen
dat0 <- simdata(a0, d0, n.persons, '2PL', Theta = matrix(x0))
dat1 <- simdata(a0, d1, n.persons, '2PL', Theta = matrix(x1))
# Fit IRT models
fit0 <- mirt(dat0, 1, SE = T, SE.type = 'Oakes')
fit1 <- mirt(dat1, 1, SE = T, SE.type = 'Oakes')
rbind(se_d(impact[1], fit0, fit1),
se_d2(impact[1], fit0, fit1),
se_d3(impact[1], fit0, fit1),
se_d4(impact[1], fit0, fit1))
# DIF Procedures
bsq.out <- irls(fit0, fit1)
true.out <- true_weights(impact[1], fit0, fit1)
lr.out <- lr(dat0, dat1)
mh.out <- MH(dat0, dat1)
lasso.out <- lasso(dat0, dat1)
# Format output
dif <- data.frame(a0 = a0,
d0 = d0,
dgp = d1-d0 != 0,
bsq.true = true.out,
bsq = bsq.out$weights,
lr = lr.out$p,
mh = mh.out$p,
lasso = lasso.out$dif
)
scale <- data.frame(bsq = bsq.out$optimize$minimum,
lr = lr.out$mu,
mh = mh.out$mu,
lasso = lasso.out$mu
)
list(dif = dif, scale = scale)
}
parallel::mclapply(1:n.reps, loop)
}
lr <- function(dat0, dat1, parms = c("d")){
dat <- rbind(dat0, dat1)
group <- c(rep("0", nrow(dat0)), rep("1", nrow(dat1)))
mg.mod <- multipleGroup(dat,
model = 1,
group = group,
invariance = c("slopes", "intercepts", "free_var","free_means"))
p <- DIF(mg.mod, which.par = parms, scheme = "drop", Wald = F)$p
mu <- coef(mg.mod)$`1`$GroupPars[1]
list(p = p, mu = mu)
}
MH <- function(dat0, dat1){
dat <- rbind(dat0, dat1)
group <- c(rep("0", nrow(dat0)), rep("1", nrow(dat1)))
p <- difR::difMH(dat, group, focal.name = 0)$p.value
mu <- mean(apply(dat1, 1, sum) - apply(dat0, 1, sum)) / sd(apply(dat0, 1, sum))
list(p = p, mu = mu)
}
# GPCMlasso
lasso <- function(dat0, dat1) {
n.items <- ncol(dat0)
dat <- data.frame(rbind(dat0, dat1))
group <- c(rep(0, nrow(dat0)), rep(1, nrow(dat1)))
dat.g <- data.frame(dat, group)
mod <- as.formula(paste("cbind(",paste(colnames(dat.g)[1:n.items],collapse=","),")~group"))
gpcm <- GPCMlasso(mod, dat.g, model = "2PL",
control = ctrl_GPCMlasso(l.lambda = 15,
adaptive = T,
steptol = 1e-4,
gradtol = 1e-4,
iterlim = 50))
mu <- coef(gpcm)[which.min(gpcm$BIC), ][(n.items+1)]
dif <- abs(coef(gpcm)[which.min(gpcm$BIC), ][(n.items+2):(2*n.items+1)])
list(dif = dif, mu = mu)
}
decision_errors <-function(ds){
test_names <- c("bsq.true", "bsq", "lr", "mh", "lasso")
cuts <- c(1e-6, 1e-6, .05, .05, 1e-6)
# test_names <- c("bsq.true", "bsq")
# cuts <- c(1e-6, 1e-6)
decisions <- data.frame(t(t(ds[,test_names]) < cuts))
decisions$lasso <- decisions$lasso == F
tp <- apply(decisions[ds$dgp == T, ], 2, mean)
fp <- apply(decisions[ds$dgp == F, ], 2, mean)
out <- data.frame(cbind(fp, tp))
out$method <- rownames(out)
rownames(out) <- NULL
out
}
se_d2 <- function(scale, fit0, fit1){
a0 <- get_parms(fit0)$a
se_d0 <- get_se(fit0)$d
se_d1 <- get_se(fit1)$d
sqrt(se_d0^2 + se_d1^2) / a0
}
# bz sim
bz_sim <- function(n.reps = 5, n.bias = "1/2", bias = "none", impact = c(0, 1), est.scale = T, parm = "d"){
require(mirt)
# Sample parms
n.persons <- 500 # per group
n.items <- 12
# Item hyper-parms. Note first item is too easy in BZ paper (.8), changed to .2
a.mu <- rep(c(.7, 1, 1.3, 1.6, 1.9, 2.2), times = 2)
a.pm <- .15
d.mu <- rep(c(.8, .2, -.4, -1, -1.6, -2.2), times = 2)
d.pm <- .3
# Item bias
if (bias == "none") {
a.delta <- rep(0, times = 12)
d.delta <- rep(0, times = 12)
}
if (bias == "small") {
a.delta <- rep(c(0, -.2, .2, .2, 0, 0), times = 2)
d.delta <- rep(c(0, -.4, .4, .4, 0, 0), times = 2)
}
if (bias == "large") {
a.delta <- rep(c(0, -.4, .8, 1, 0, 0), times = 2)
d.delta <- rep(c(0, -1, 1.1, 1.2, 0, 0), times = 2)
}
if (n.bias == "1/3"){
omits <- c(1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1)
a.delta <- a.delta * omits
d.delta <- d.delta * omits
}
loop <- function(i){
# DGP
a0 <- runif(n.items, a.mu - a.pm, a.mu + a.pm)
a1 <- a0 + a.delta
d0 <- runif(n.items, d.mu - d.pm, d.mu + d.pm)
d1 <- d0 + d.delta
x0 <- rnorm(n.persons)
x1 <- impact[2]*rnorm(n.persons) + impact[1]
# Data gen
dat0 <- simdata(a0, d0, n.persons, '2PL', Theta = matrix(x0))
dat1 <- simdata(a1, d1, n.persons, '2PL', Theta = matrix(x1))
# Fit IRT models
fit0 <- mirt(dat0, 1, SE = T, SE.type = 'Oakes')
fit1 <- mirt(dat1, 1, SE = T, SE.type = 'Oakes')
if (est.scale) {
out <- irls_r(fit0, fit1, parm)
} else {
se.d <- se_d(fit0, fit1)
bsq.cut <- bsq_cut(se.d)
weights <- bsq_weight(impact[1], fit0, fit1, bsq.cut)
out <- list(weights = weights)
}
out
}
parallel::mclapply(1:n.reps, loop)
}
n500.6 <- n_sim(n.reps, n.persons = 500, n.items = 15, n.biased = 6, bias = .5, impact = c(.5, 1))
